{
    "markdown":"# 项目介绍\n 框架使用：**AntdPro**  + **React** + **Umi**\n markdown解析渲染使用：**marked**\n\n## 使用方法\ntextarea内输入markdown语法，自动渲染右边HTML内容\n \n## 代码展示\n\n\n左边 **Markdown** ，右边**HTML**\n\n# TOC自动生成\n> markdown 解析的时候会通过 rendeer.heading 解析标题，然后我们在 rendeer.heading 使用 tocify.add 来生成目录树（根据 level）并返回一个锚点，rendeer.heading 再根据这个锚点生成一个 a 链接，最后我们调用 tocify.render () 渲染就可以了\n\ntocify.tsx\n```typescript\nimport React from 'react';\nimport { Anchor } from 'antd';\nimport { last } from 'lodash';\n\nconst { Link } = Anchor;\n\nexport interface TocItem {\n    anchor: string;\n    level: number;\n    text: string;\n    children?: TocItem[];\n}\n\nexport type TocItems = TocItem[]; // TOC目录树结构\n\nexport default class Tocify {\n    tocItems: TocItems = [];\n\n    index: number = 0;\n\n    constructor() {\n        this.tocItems = [];\n        this.index = 0;\n    }\n\n    add(text: string, level: number) {\n        console.log(text, level)\n        const anchor = `toc${level}${++this.index}`;\n        const item = { anchor, level, text };\n        const items = this.tocItems;\n\n        if (items.length === 0) { // 第一个 item 直接 push\n            items.push(item);\n        } else {\n            let lastItem = last(items) as TocItem; // 最后一个 item\n\n            if (item.level > lastItem.level) { // item 是 lastItem 的 children\n                for (let i = lastItem.level + 1; i <= 2; i++) {\n                    const { children } = lastItem;\n                    if (!children) { // 如果 children 不存在\n                        lastItem.children = [item];\n                        break;\n                    }\n\n                    lastItem = last(children) as TocItem; // 重置 lastItem 为 children 的最后一个 item\n\n                    if (item.level <= lastItem.level) { // item level 小于或等于 lastItem level 都视为与 children 同级\n                        children.push(item);\n                        break;\n                    }\n                }\n            } else { // 置于最顶级\n                items.push(item);\n            }\n        }\n\n        return anchor;\n    }\n\n    reset = () => {\n        this.tocItems = [];\n        this.index = 0;\n    };\n\n    renderToc(items: TocItem[]) { // 递归 render\n        return items.map(item => (\n            <Link key={item.anchor} href={`#${item.anchor}`} title={item.text}>\n                {item.children && this.renderToc(item.children)}\n            </Link>\n        ));\n    }\n\n    render() {\n        return (\n            <Anchor affix showInkInFixed>\n                {this.renderToc(this.tocItems)}\n            </Anchor>\n        );\n    }\n}\n```\n\n## 在使用组件中重写 renderer.heading,重新配置a标签\n```typescript\nconst tocify = new Tocify()\n  const renderer = new marked.Renderer()\n  renderer.heading = (text: string, level: number) => {\n    console.log(text)\n    const anchor = tocify.add(text, level)\n    return `<a id=\"${anchor}\" href=\"#${anchor}\" ><h${level}>${text}</h${level}></a>\\n`;\n  }\n```"
}